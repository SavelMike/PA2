Task: arbitrary precision calculator

1. Exact task specification
  User interaction:
    1) Expression evaluation // See below expr_evaluation
    2) Variable assignment: varname = expression
    3) "quit" - program terminates
    4) "help" - document available actions
    5) "save" - save current state of calculator to file
    6) "load" - load previously saved state back from file

2. Polymorphism design
Base class CLexem
    // Numbers, variable names, parentheses, operators(+, -, *, /, %)
Base class CResult: public CLexem
class CIntnumber: public CResult
class CIntvar: public CIntnumber
class CFractnumber: public CResult
class CFractvar: public CFractnumber

Base class: CExpression
    virtual CResult calculate() 
class CAdd: public CExpression
class CSubstract: public CExpression
class CMultiply: public CExpression
class CDivision: public CExpression
class CMod: public CExpression

Class CPostfix
{
	add(istream& is); // Add lexema to postfix notation (part of conversion from infix notation)		
	calculate(); // Calculate value of expression using postfix notation
}
  
expr_evaluation()
{
	CPostfix expr;
	while (expr.add(is)) { ; }
	cout << expr.calculate() << endl;
}

3. Base implementation - header files with class declarations,
Use postfix notation to calculate input expression: 
    pros:
	1. Recursion algoritms are not required
	2. Handling of parentheses simplified 
Use container vector<CLexem*> as stack for manipulation postfix notation (using push_back and pop_back). 

4. Work in progress implementation - cpp files




